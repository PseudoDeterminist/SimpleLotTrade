// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/*
  STRN10KLotCLOB v0.3.3 (Mordor / Permit-friendly tokens)
  -------------------------------------------------------
  This version keeps the exact same CLOB + FOK taker semantics as v0.3.2,
  but removes internal deposit/withdraw balances entirely.

  - Tick-only CLOB
  - Integer lots only (STRN10K lots, decimals=0)
  - Zero fees
  - NO internal balances / NO deposits / NO withdrawals
  - Escrow lives ONLY inside open orders:
      * Buy orders escrow TETC (quoteRemaining)
      * Sell orders escrow STRN10K (lotsRemaining)
  - Takers are FOK only:
      * takeBuyFOK pulls worst-case TETC upfront, fills or reverts, refunds improvement
      * takeSellFOK pulls STRN10K upfront, fills or reverts
  - Oracle = lastTradeTick / lastTradeBlock
  - Full-book + depth getters are SINGLE-PASS bounded and return (array, n)
  - Price grid: 128 ticks per doubling, using tickPrices[0..127] + octave shifts
  - Price snapping: 1e13 wei grid (“6 digits incl leading 1”)
  - Math-bounded ticks: [-2048, +2048]

  Notes:
  - This contract does NOT need to know about permits. Your UI can call permit() on the
    token(s) first (once, big allowance or as-needed), then call the exchange, which
    only uses transferFrom/transfer.
*/

interface IERC20 {
    function transfer(address to, uint256 value) external returns (bool);
    function transferFrom(address from, address to, uint256 value) external returns (bool);
}

/* ===================== Lot CLOB ===================== */

contract STRN10KLotCLOB {
    IERC20 public immutable TETC;     // 18 decimals (quote token)
    IERC20 public immutable STRN10K;  // 0 decimals (base token; "lots")

    int32 private constant NONE = type(int32).min;

    // Math bound (not economics): with the current design this is extremely safe.
    int32 private constant MIN_TICK = -2048;
    int32 private constant MAX_TICK =  2048;

    // 1e13 snapping grid (5 decimals after ".", “6 sig digits incl leading 1” for ~1.x prices)
    uint256 private constant WEI_GRID = 10_000_000_000_000; // 1e13

    // tickPrices[r] for r=0..127 correspond to ticks 0..127 at octave=0 (1 TETC at tick 0),
    // already snapped down to the 1e13 grid.
    uint256[128] private tickPrices = [
        1000000000000000000,
        1005420000000000000,
        1010880000000000000,
        1016370000000000000,
        1021890000000000000,
        1027440000000000000,
        1033020000000000000,
        1038630000000000000,
        1044270000000000000,
        1049940000000000000,
        1055640000000000000,
        1061370000000000000,
        1067140000000000000,
        1072930000000000000,
        1078760000000000000,
        1084610000000000000,
        1090500000000000000,
        1096420000000000000,
        1102380000000000000,
        1108370000000000000,
        1114390000000000000,
        1120450000000000000,
        1126540000000000000,
        1132670000000000000,
        1138830000000000000,
        1145020000000000000,
        1151250000000000000,
        1157510000000000000,
        1163810000000000000,
        1170150000000000000,
        1176520000000000000,
        1182920000000000000,
        1189360000000000000,
        1195840000000000000,
        1202360000000000000,
        1208910000000000000,
        1215500000000000000,
        1222120000000000000,
        1228780000000000000,
        1235480000000000000,
        1242220000000000000,
        1248990000000000000,
        1255810000000000000,
        1262660000000000000,
        1269550000000000000,
        1276470000000000000,
        1283440000000000000,
        1290450000000000000,
        1297490000000000000,
        1304580000000000000,
        1311700000000000000,
        1318860000000000000,
        1326060000000000000,
        1333310000000000000,
        1340590000000000000,
        1347920000000000000,
        1355280000000000000,
        1362690000000000000,
        1370140000000000000,
        1377630000000000000,
        1385160000000000000,
        1392730000000000000,
        1400350000000000000,
        1408010000000000000,
        1415710000000000000,
        1423460000000000000,
        1431250000000000000,
        1439080000000000000,
        1446960000000000000,
        1454880000000000000,
        1462850000000000000,
        1470860000000000000,
        1478920000000000000,
        1487030000000000000,
        1495180000000000000,
        1503370000000000000,
        1511620000000000000,
        1519910000000000000,
        1528240000000000000,
        1536630000000000000,
        1545060000000000000,
        1553540000000000000,
        1562060000000000000,
        1570640000000000000,
        1579260000000000000,
        1587940000000000000,
        1596660000000000000,
        1605430000000000000,
        1614250000000000000,
        1623110000000000000,
        1632030000000000000,
        1641000000000000000,
        1650020000000000000,
        1659090000000000000,
        1668210000000000000,
        1677380000000000000,
        1686610000000000000,
        1695880000000000000,
        1705210000000000000,
        1714590000000000000,
        1724020000000000000,
        1733500000000000000,
        1743040000000000000,
        1752630000000000000,
        1762280000000000000,
        1771980000000000000,
        1781730000000000000,
        1791540000000000000,
        1801400000000000000,
        1811320000000000000,
        1821290000000000000,
        1831330000000000000,
        1841410000000000000,
        1851560000000000000,
        1861760000000000000,
        1872020000000000000,
        1882330000000000000,
        1892710000000000000,
        1903140000000000000,
        1913630000000000000,
        1924180000000000000,
        1934790000000000000,
        1945460000000000000,
        1956190000000000000,
        1966980000000000000,
        1977830000000000000,
        1988750000000000000
    ];

    // Oracle
    int32 public lastTradeTick;
    uint256 public lastTradeBlock;

    // Reentrancy guard (for token transfers)
    uint256 private _lock = 1;
    modifier nonReentrant() {
        require(_lock == 1, "reentrancy");
        _lock = 2;
        _;
        _lock = 1;
    }

    struct Order {
        address owner;
        int32 tick;
        uint32 lotsRemaining;
        bool isBuy;

        // Escrowed quote for BUY orders only (TETC smallest units).
        // For SELL orders, escrow is the base token lotsRemaining (STRN10K held by contract).
        uint256 quoteRemaining;

        uint256 prev;
        uint256 next;
        bool exists;
    }

    struct TickLevel {
        bool exists;
        int32 prev;
        int32 next;
        uint256 head;
        uint256 tail;
        uint32 orderCount;
        uint32 totalLots;
    }

    uint256 public nextOrderId = 1;

    mapping(uint256 => Order) public orders;
    mapping(int32 => TickLevel) public buyLevels;
    mapping(int32 => TickLevel) public sellLevels;

    bool public hasBestBuy;
    bool public hasBestSell;
    int32 public bestBuyTick;
    int32 public bestSellTick;

    // Book return structs
    struct BookOrder {
        uint256 id;
        address owner;
        int32 tick;
        uint32 lotsRemaining;
    }

    struct BookLevel {
        int32 tick;
        uint32 totalLots;
        uint32 orderCount;
    }

    constructor(address tetcToken, address strn10kToken) {
        require(tetcToken != address(0), "zero TETC");
        require(strn10kToken != address(0), "zero STRN10K");
        TETC = IERC20(tetcToken);
        STRN10K = IERC20(strn10kToken);
        bestBuyTick = NONE;
        bestSellTick = NONE;
    }

    /* ---------- Maker Orders (escrow on placement) ---------- */

    /// @notice Place a BUY: escrow TETC = lots * price(tick) into the order.
    /// @dev Caller must already have allowance (via approve or permit UI flow).
    function placeBuy(int32 tick, uint32 lots) external nonReentrant returns (uint256 id) {
        require(lots > 0, "zero lots");
        uint256 price = _weiPerLotFromTick(tick);
        uint256 cost = uint256(lots) * price;

        require(TETC.transferFrom(msg.sender, address(this), cost), "TETC transferFrom failed");

        id = _newOrder(true, tick, lots, cost);
        _enqueue(true, tick, id);
    }

    /// @notice Place a SELL: escrow STRN10K lots into the order.
    /// @dev Caller must already have allowance (via approve or permit UI flow).
    function placeSell(int32 tick, uint32 lots) external nonReentrant returns (uint256 id) {
        require(lots > 0, "zero lots");
        require(STRN10K.transferFrom(msg.sender, address(this), uint256(lots)), "STRN10K transferFrom failed");

        id = _newOrder(false, tick, lots, 0);
        _enqueue(false, tick, id);
    }

    /// @notice Cancel an order and return any remaining escrow.
    function cancel(uint256 id) external nonReentrant {
        Order storage o = orders[id];
        require(o.exists && o.owner == msg.sender, "not owner");

        if (o.isBuy) {
            // Refund remaining quote escrow
            uint256 refund = o.quoteRemaining;
            if (refund > 0) {
                o.quoteRemaining = 0;
                require(TETC.transfer(msg.sender, refund), "TETC refund failed");
            }
            buyLevels[o.tick].totalLots -= o.lotsRemaining;
        } else {
            // Refund remaining base escrow
            uint256 refundLots = uint256(o.lotsRemaining);
            if (refundLots > 0) {
                o.lotsRemaining = 0;
                require(STRN10K.transfer(msg.sender, refundLots), "STRN10K refund failed");
            }
            sellLevels[o.tick].totalLots -= o.lotsRemaining; // now 0, but keep symmetry
        }

        _unlinkOrder(o.isBuy, o.tick, id);
        delete orders[id];
    }

    /* ---------- Taker FOK (no balances; in-loop transfers; revert if not fully filled) ---------- */

    /// @notice Buy `lots` lots, paying up to `limitTick` (must fill completely or revert).
    /// @dev Pulls worst-case TETC upfront (lots * price(limitTick)), refunds improvement at end.
    function takeBuyFOK(int32 limitTick, uint32 lots) external nonReentrant {
        require(lots > 0, "zero lots");
        require(hasBestSell, "no sells");

        uint256 limitPrice = _weiPerLotFromTick(limitTick);
        uint256 worst = uint256(lots) * limitPrice;

        // Pull worst-case quote upfront (UI can set allowance with permit)
        require(TETC.transferFrom(msg.sender, address(this), worst), "TETC transferFrom failed");

        uint32 remain = lots;
        int32 t = bestSellTick;
        int32 lastFilled;
        bool filledAny;
        uint256 spent = 0;

        while (remain > 0) {
            require(hasBestSell, "FOK");        // book emptied
            require(t <= limitTick, "FOK");     // price crossed

            TickLevel storage lvl = sellLevels[t];
            uint256 oid = lvl.head;
            require(oid != 0, "empty level");

            Order storage m = orders[oid];
            uint32 f = m.lotsRemaining > remain ? remain : m.lotsRemaining;

            uint256 price = _weiPerLotFromTick(t);
            uint256 pay = uint256(f) * price;

            // Effects first
            m.lotsRemaining -= f;
            lvl.totalLots -= f;
            remain -= f;

            spent += pay;
            lastFilled = t;
            filledAny = true;

            // Interactions: pay maker (seller) and deliver lots to taker
            require(TETC.transfer(m.owner, pay), "TETC pay maker failed");
            require(STRN10K.transfer(msg.sender, uint256(f)), "STRN10K pay taker failed");

            if (m.lotsRemaining == 0) {
                _removeHead(false, t);
                delete orders[oid];
            }

            if (lvl.head == 0) {
                int32 nxt = lvl.next;
                _removeTick(false, t);
                if (!hasBestSell) break;
                if (nxt == NONE) break;
                t = nxt;
            }
        }

        require(remain == 0, "unfilled");

        // Refund any improvement (worst - spent)
        if (spent < worst) {
            require(TETC.transfer(msg.sender, worst - spent), "TETC refund failed");
        }

        if (filledAny) {
            lastTradeTick = lastFilled;
            lastTradeBlock = block.number;
        }
    }

    /// @notice Sell `lots` lots, receiving at least `limitTick` (must fill completely or revert).
    /// @dev Pulls STRN10K upfront, then pays out from maker BUY escrows (quoteRemaining).
    function takeSellFOK(int32 limitTick, uint32 lots) external nonReentrant {
        require(lots > 0, "zero lots");
        require(hasBestBuy, "no buys");

        // Pull base upfront
        require(STRN10K.transferFrom(msg.sender, address(this), uint256(lots)), "STRN10K transferFrom failed");

        uint32 remain = lots;
        int32 t = bestBuyTick;
        int32 lastFilled;
        bool filledAny;

        while (remain > 0) {
            require(hasBestBuy, "FOK");         // book emptied
            require(t >= limitTick, "FOK");     // price crossed

            TickLevel storage lvl = buyLevels[t];
            uint256 oid = lvl.head;
            require(oid != 0, "empty level");

            Order storage m = orders[oid];
            uint32 f = m.lotsRemaining > remain ? remain : m.lotsRemaining;

            uint256 price = _weiPerLotFromTick(t);
            uint256 pay = uint256(f) * price;

            // Effects first
            require(m.quoteRemaining >= pay, "maker escrow");
            m.quoteRemaining -= pay;

            m.lotsRemaining -= f;
            lvl.totalLots -= f;
            remain -= f;

            lastFilled = t;
            filledAny = true;

            // Interactions: pay taker in TETC from escrow; deliver lots to maker from pulled base
            require(TETC.transfer(msg.sender, pay), "TETC pay taker failed");
            require(STRN10K.transfer(m.owner, uint256(f)), "STRN10K pay maker failed");

            if (m.lotsRemaining == 0) {
                // If invariant holds, quoteRemaining should be 0 now
                _removeHead(true, t);
                delete orders[oid];
            }

            if (lvl.head == 0) {
                int32 nxt = lvl.next;
                _removeTick(true, t);
                if (!hasBestBuy) break;
                if (nxt == NONE) break;
                t = nxt;
            }
        }

        require(remain == 0, "unfilled");

        if (filledAny) {
            lastTradeTick = lastFilled;
            lastTradeBlock = block.number;
        }
    }

    /* ---------- Full Book + Depth Views (single-pass, bounded) ---------- */

    function getFullBuyBook(uint256 maxOrders)
        external
        view
        returns (BookOrder[] memory out, uint256 n)
    {
        return _getFullBookSinglePass(true, maxOrders);
    }

    function getFullSellBook(uint256 maxOrders)
        external
        view
        returns (BookOrder[] memory out, uint256 n)
    {
        return _getFullBookSinglePass(false, maxOrders);
    }

    function _getFullBookSinglePass(bool isBuy, uint256 maxOrders)
        internal
        view
        returns (BookOrder[] memory out, uint256 n)
    {
        if (maxOrders == 0) return (new BookOrder[](0), 0);

        if (isBuy) {
            if (!hasBestBuy) return (new BookOrder[](0), 0);
        } else {
            if (!hasBestSell) return (new BookOrder[](0), 0);
        }

        out = new BookOrder[](maxOrders);
        n = 0;

        if (isBuy) {
            int32 t = bestBuyTick;
            while (t != NONE && n < maxOrders) {
                TickLevel storage lvl = buyLevels[t];
                uint256 oid = lvl.head;
                while (oid != 0 && n < maxOrders) {
                    Order storage o = orders[oid];
                    out[n++] = BookOrder(oid, o.owner, o.tick, o.lotsRemaining);
                    oid = o.next;
                }
                t = lvl.next;
            }
        } else {
            int32 t = bestSellTick;
            while (t != NONE && n < maxOrders) {
                TickLevel storage lvl = sellLevels[t];
                uint256 oid = lvl.head;
                while (oid != 0 && n < maxOrders) {
                    Order storage o = orders[oid];
                    out[n++] = BookOrder(oid, o.owner, o.tick, o.lotsRemaining);
                    oid = o.next;
                }
                t = lvl.next;
            }
        }
    }

    function getBuyBookDepth(uint256 maxLevels)
        external
        view
        returns (BookLevel[] memory out, uint256 n)
    {
        return _getDepthSinglePass(true, maxLevels);
    }

    function getSellBookDepth(uint256 maxLevels)
        external
        view
        returns (BookLevel[] memory out, uint256 n)
    {
        return _getDepthSinglePass(false, maxLevels);
    }

    function _getDepthSinglePass(bool isBuy, uint256 maxLevels)
        internal
        view
        returns (BookLevel[] memory out, uint256 n)
    {
        if (maxLevels == 0) return (new BookLevel[](0), 0);

        if (isBuy) {
            if (!hasBestBuy) return (new BookLevel[](0), 0);
        } else {
            if (!hasBestSell) return (new BookLevel[](0), 0);
        }

        out = new BookLevel[](maxLevels);
        n = 0;

        if (isBuy) {
            int32 t = bestBuyTick;
            while (t != NONE && n < maxLevels) {
                TickLevel storage lvl = buyLevels[t];
                if (lvl.totalLots > 0) out[n++] = BookLevel(t, lvl.totalLots, lvl.orderCount);
                t = lvl.next;
            }
        } else {
            int32 t = bestSellTick;
            while (t != NONE && n < maxLevels) {
                TickLevel storage lvl = sellLevels[t];
                if (lvl.totalLots > 0) out[n++] = BookLevel(t, lvl.totalLots, lvl.orderCount);
                t = lvl.next;
            }
        }
    }

    function getTopOfBook() external view returns (
        bool hasBuy, int32 buyTick, uint32 buyLots, uint32 buyOrders,
        bool hasSell, int32 sellTick, uint32 sellLots, uint32 sellOrders
    ) {
        hasBuy = hasBestBuy;
        buyTick = bestBuyTick;
        if (hasBuy) {
            TickLevel storage b = buyLevels[buyTick];
            buyLots = b.totalLots;
            buyOrders = b.orderCount;
        }

        hasSell = hasBestSell;
        sellTick = bestSellTick;
        if (hasSell) {
            TickLevel storage s = sellLevels[sellTick];
            sellLots = s.totalLots;
            sellOrders = s.orderCount;
        }
    }

    /* ---------- Internals ---------- */

    function _newOrder(bool isBuy, int32 tick, uint32 lots, uint256 quoteRemaining) internal returns (uint256 id) {
        id = nextOrderId++;
        orders[id] = Order(msg.sender, tick, lots, isBuy, quoteRemaining, 0, 0, true);
    }

    function _enqueue(bool isBuy, int32 tick, uint256 id) internal {
        TickLevel storage lvl = isBuy ? buyLevels[tick] : sellLevels[tick];

        if (!lvl.exists) {
            _insertTick(isBuy, tick);
            lvl = isBuy ? buyLevels[tick] : sellLevels[tick];
        }

        if (lvl.tail == 0) {
            lvl.head = id;
            lvl.tail = id;
        } else {
            orders[lvl.tail].next = id;
            orders[id].prev = lvl.tail;
            lvl.tail = id;
        }

        lvl.orderCount++;
        lvl.totalLots += orders[id].lotsRemaining;
    }

    function _insertTick(bool isBuy, int32 tick) internal {
        TickLevel storage lvl = isBuy ? buyLevels[tick] : sellLevels[tick];
        lvl.exists = true;
        lvl.prev = NONE;
        lvl.next = NONE;

        if (isBuy) {
            if (!hasBestBuy) {
                hasBestBuy = true;
                bestBuyTick = tick;
                return;
            }
            int32 cur = bestBuyTick;
            if (tick > cur) {
                lvl.next = cur;
                buyLevels[cur].prev = tick;
                bestBuyTick = tick;
                return;
            }
            while (true) {
                int32 nxt = buyLevels[cur].next;
                if (nxt == NONE || tick > nxt) {
                    lvl.prev = cur;
                    lvl.next = nxt;
                    buyLevels[cur].next = tick;
                    if (nxt != NONE) buyLevels[nxt].prev = tick;
                    return;
                }
                cur = nxt;
            }
        } else {
            if (!hasBestSell) {
                hasBestSell = true;
                bestSellTick = tick;
                return;
            }
            int32 cur = bestSellTick;
            if (tick < cur) {
                lvl.next = cur;
                sellLevels[cur].prev = tick;
                bestSellTick = tick;
                return;
            }
            while (true) {
                int32 nxt = sellLevels[cur].next;
                if (nxt == NONE || tick < nxt) {
                    lvl.prev = cur;
                    lvl.next = nxt;
                    sellLevels[cur].next = tick;
                    if (nxt != NONE) sellLevels[nxt].prev = tick;
                    return;
                }
                cur = nxt;
            }
        }
    }

    function _removeHead(bool isBuy, int32 tick) internal {
        TickLevel storage lvl = isBuy ? buyLevels[tick] : sellLevels[tick];
        uint256 id = lvl.head;
        uint256 n = orders[id].next;
        lvl.head = n;
        if (n == 0) lvl.tail = 0;
        else orders[n].prev = 0;
        lvl.orderCount--;
    }

    function _unlinkOrder(bool isBuy, int32 tick, uint256 id) internal {
        TickLevel storage lvl = isBuy ? buyLevels[tick] : sellLevels[tick];
        Order storage o = orders[id];

        if (o.prev == 0) lvl.head = o.next;
        else orders[o.prev].next = o.next;

        if (o.next == 0) lvl.tail = o.prev;
        else orders[o.next].prev = o.prev;

        lvl.orderCount--;
        if (lvl.head == 0) _removeTick(isBuy, tick);
    }

    function _removeTick(bool isBuy, int32 tick) internal {
        TickLevel storage lvl = isBuy ? buyLevels[tick] : sellLevels[tick];
        int32 p = lvl.prev;
        int32 n = lvl.next;

        if (isBuy) {
            if (p == NONE) bestBuyTick = n;
            else buyLevels[p].next = n;
            if (n != NONE) buyLevels[n].prev = p;
            if (bestBuyTick == NONE) hasBestBuy = false;
            delete buyLevels[tick];
        } else {
            if (p == NONE) bestSellTick = n;
            else sellLevels[p].next = n;
            if (n != NONE) sellLevels[n].prev = p;
            if (bestSellTick == NONE) hasBestSell = false;
            delete sellLevels[tick];
        }
    }

    /* ---------- Price Views ---------- */

    /// @notice TETC units per 1 lot at `tick`, using tickPrices[] table + octave shifts.
    /// @dev Final result is snapped down to 1e13 for ALL ticks (including negative octaves).
    function _weiPerLotFromTick(int32 tick) internal view returns (uint256) {
        require(tick >= MIN_TICK && tick <= MAX_TICK, "tick range");

        int32 octave = tick / 128;
        int32 r = tick % 128;
        if (r < 0) { r += 128; octave -= 1; }

        uint256 p = tickPrices[uint256(uint32(r))];

        if (octave > 0) {
            p <<= uint32(octave);
        } else if (octave < 0) {
            p >>= uint32(-octave);
        }

        // Snap to the chosen decimal grid (keeps on-chain numbers aligned with UI precision policy)
        p = (p / WEI_GRID) * WEI_GRID;
        return p;
    }

    function weiPerLotForTick(int32 tick) external view returns (uint256) {
        return _weiPerLotFromTick(tick);
    }

    function getBestTicks() external view returns (bool, int32, bool, int32) {
        return (hasBestBuy, bestBuyTick, hasBestSell, bestSellTick);
    }

    function getLevel(bool isBuy, int32 tick) external view returns (
        bool exists,
        int32 prev,
        int32 next,
        uint256 head,
        uint256 tail,
        uint32 orderCount,
        uint32 totalLots
    ) {
        TickLevel storage l = isBuy ? buyLevels[tick] : sellLevels[tick];
        return (l.exists, l.prev, l.next, l.head, l.tail, l.orderCount, l.totalLots);
    }
}
