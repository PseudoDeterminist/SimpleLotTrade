// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/*
  STRN10KLotCLOB v0.4.0 (Mordor Testnet)
  -------------------------------------
  - Tick-only CLOB for STRN10K lots (decimals=0), priced in TETC (18 decimals)
  - FOK takers only (same as v0.3.x logic)
  - NO internal deposit/withdraw balances:
      * Makers escrow tokens inside the contract on order placement
      * Escrow is released on fill/partial fill/cancel
  - Trusted tokens assumption: TETC and STRN10K are our own ERC-20s (with EIP-2612 support).
    Exchange does NOT call permit; UI/users can permit/approve once, then call exchange functions.
  - Price grid:
      * 462 ticks per decade (~0.5% per tick)
      * Mantissa table: uint16 values (1000..9950) representing (mantissa * 1e15) at decade=0
      * Tick 0 price = 1e18 (i.e., 1.000 TETC per lot)
      * Tick range: [-1848, +1848]  (i.e., [-4 decades, +4 decades])
*/

interface IERC20 {
    function transfer(address to, uint256 value) external returns (bool);
    function transferFrom(address from, address to, uint256 value) external returns (bool);
}


/* ===================== Lot CLOB ===================== */

contract STRN10KLotCLOB {
    IERC20 public immutable TETC;    // quote token (18 decimals)
    IERC20 public immutable STRN10K; // base token (0 decimals, integer lots)

    int32 private constant NONE = type(int32).min;

    // Tick range: -462*4 .. +462*4
    int32 private constant MIN_TICK = -1848;
    int32 private constant MAX_TICK =  1848;
/* ===================== Packed Mantissa Table (462/decade) ===================== */

    /// @notice Packed mantissa table for 462 ticks-per-decade.
    /// Each mantissa is a uint16 in [1000..9950] representing (mantissa * 1e15) wei at decade 0.
    /// tickPriceWei = mantissa[r] * 1e15 * 10^decade, where tick = decade*462 + r (with r in [0..461]).
    /// For negative decades, divide by 10^{-decade} (integer floor).
    bytes32[29] internal MANT = [
        bytes32(0x03e803ed03f203f703fc04010406040c04110416041b04200426042b04300436),
        bytes32(0x043b04400446044b04510456045c04610467046d04720478047e04840489048f),
        bytes32(0x0495049b04a104a704ad04b304b904bf04c504cb04d104d704dd04e304ea04f0),
        bytes32(0x04f604fd0503050905100516051d0523052a05310537053e0545054b05520559),
        bytes32(0x05600567056d0574057b0582058905910598059f05a605ad05b505bc05c305cb),
        bytes32(0x05d205d905e105e805f005f805ff0607060f0616061e0626062e0636063e0646),
        bytes32(0x064e0656065e0666066e0676067f0687068f069806a006a906b106ba06c206cb),
        bytes32(0x06d406dc06e506ee06f7070007090712071b0724072d0736073f07490752075b),
        bytes32(0x0765076e07780781078b0794079e07a807b207bb07c507cf07d907e307ed07f8),
        bytes32(0x0802080c08160821082b08350840084a08550860086a08750880088b089608a1),
        bytes32(0x08ac08b708c208cd08d908e408ef08fb09060912091d092909350940094c0958),
        bytes32(0x09640970097c0988099509a109ad09b909c609d209df09ec09f80a050a120a1f),
        bytes32(0x0a2c0a390a460a530a600a6d0a7b0a880a960aa30ab10abe0acc0ada0ae80af6),
        bytes32(0x0b040b120b200b2e0b3d0b4b0b590b680b760b850b940ba30bb20bc10bd00bdf),
        bytes32(0x0bee0bfd0c0c0c1c0c2b0c3b0c4b0c5a0c6a0c7a0c8a0c9a0caa0cba0ccb0cdb),
        bytes32(0x0ceb0cfc0d0c0d1d0d2e0d3f0d500d610d720d830d940da60db70dc90dda0dec),
        bytes32(0x0dfe0e100e220e340e460e580e6b0e7d0e900ea20eb50ec80edb0eee0f010f14),
        bytes32(0x0f270f3b0f4e0f620f750f890f9d0fb10fc50fd90fed10021016102b10401054),
        bytes32(0x1069107e109310a910be10d310e910fe1114112a11401156116c1182119911af),
        bytes32(0x11c611dd11f4120b1222123912501268127f129712ae12c612de12f7130f1327),
        bytes32(0x134013581371138a13a313bc13d513ef14081422143b1455146f148914a414be),
        bytes32(0x14d914f3150e15291544155f157b159615b215ce15e916051622163e165a1677),
        bytes32(0x169416b116ce16eb1708172617431761177f179d17bb17d917f8181718351854),
        bytes32(0x1873189318b218d218f11911193119521972199319b319d419f51a161a381a59),
        bytes32(0x1a7b1a9d1abf1ae11b041b261b491b6c1b8f1bb21bd51bf91c1d1c411c651c89),
        bytes32(0x1cae1cd21cf71d1c1d421d671d8d1db21dd81dff1e251e4c1e721e991ec01ee8),
        bytes32(0x1f0f1f371f5f1f871faf1fd8200120292053207c20a620cf20f92123214e2178),
        bytes32(0x21a321ce21f922252251227d22a922d52302232e235b238923b623e424122440),
        bytes32(0x246e249d24cb24fb252a2559258925b925e9261a264b267c26ad26de00000000)
    ];

    function mantissa(uint32 r) internal view returns (uint256 m) {
        require(r < 462, "r");
        bytes32 w = MANT[r >> 4];             // 16 per word
        uint256 shift = (15 - (r & 15)) * 16; // MSB-first packing
        m = (uint256(w) >> shift) & 0xFFFF;
    }

    // 10^k for k=0..4
    uint256[5] private POW10 = [uint256(1), 10, 100, 1000, 10000];

    // Oracle
    int32 public lastTradeTick;
    uint256 public lastTradeBlock;

    // Reentrancy guard (token transfers)
    uint256 private _lock = 1;
    modifier nonReentrant() {
        require(_lock == 1, "reentrancy");
        _lock = 2;
        _;
        _lock = 1;
    }

    struct Order {
        address owner;
        int32 tick;
        uint32 lotsRemaining;
        bool isBuy;     // buy lots for TETC, or sell lots for TETC
        uint256 prev;
        uint256 next;
        bool exists;
    }

    struct TickLevel {
        bool exists;
        int32 prev;
        int32 next;
        uint256 head;
        uint256 tail;
        uint32 orderCount;
        uint32 totalLots;
    }

    uint256 public nextOrderId = 1;

    mapping(uint256 => Order) public orders;
    mapping(int32 => TickLevel) public buyLevels;
    mapping(int32 => TickLevel) public sellLevels;

    bool public hasBestBuy;
    bool public hasBestSell;
    int32 public bestBuyTick;
    int32 public bestSellTick;

    // Book return structs
    struct BookOrder {
        uint256 id;
        address owner;
        int32 tick;
        uint32 lotsRemaining;
    }

    struct BookLevel {
        int32 tick;
        uint32 totalLots;
        uint32 orderCount;
    }

    constructor(address tetcToken, address strn10kToken) {
        require(tetcToken != address(0), "zero TETC");
        require(strn10kToken != address(0), "zero STRN10K");
        TETC = IERC20(tetcToken);
        STRN10K = IERC20(strn10kToken);
        bestBuyTick = NONE;
        bestSellTick = NONE;
    }

    /* ---------- Maker Orders (escrow on placement) ---------- */

    function placeBuy(int32 tick, uint32 lots) external nonReentrant returns (uint256 id) {
        require(lots > 0, "zero lots");

        uint256 price = _tetcPerLotFromTick(tick);
        uint256 cost = uint256(lots) * price;

        // Escrow TETC in this contract
        require(TETC.transferFrom(msg.sender, address(this), cost), "TETC transferFrom failed");

        id = _newOrder(true, tick, lots);
        _enqueue(true, tick, id);
    }

    function placeSell(int32 tick, uint32 lots) external nonReentrant returns (uint256 id) {
        require(lots > 0, "zero lots");

        // Escrow STRN10K lots in this contract (integer token)
        require(STRN10K.transferFrom(msg.sender, address(this), uint256(lots)), "STRN10K transferFrom failed");

        id = _newOrder(false, tick, lots);
        _enqueue(false, tick, id);
    }

    function cancel(uint256 id) external nonReentrant {
        Order storage o = orders[id];
        require(o.exists && o.owner == msg.sender, "not owner");

        // Refund remaining escrow
        if (o.isBuy) {
            uint256 refund = uint256(o.lotsRemaining) * _tetcPerLotFromTick(o.tick);
            require(TETC.transfer(msg.sender, refund), "TETC refund failed");
            buyLevels[o.tick].totalLots -= o.lotsRemaining;
        } else {
            uint256 refundLots = uint256(o.lotsRemaining);
            require(STRN10K.transfer(msg.sender, refundLots), "STRN10K refund failed");
            sellLevels[o.tick].totalLots -= o.lotsRemaining;
        }

        _unlinkOrder(o.isBuy, o.tick, id);
        delete orders[id];
    }

    /* ---------- Taker FOK ---------- */

    /// @notice Buy `lots` lots, paying TETC, crossing the sell book up to `limitTick`.
    /// @dev Transfers are done during the loop (trusted tokens assumption).
    function takeBuyFOK(int32 limitTick, uint32 lots) external nonReentrant {
        require(hasBestSell, "no sells");
        require(lots > 0, "zero lots");

        uint32 remain = lots;
        int32 t = bestSellTick;
        int32 lastFilled;
        bool filled;

        while (remain > 0) {
            require(t <= limitTick, "FOK");

            TickLevel storage lvl = sellLevels[t];
            uint256 oid = lvl.head;
            require(oid != 0, "empty level");

            Order storage m = orders[oid];
            uint32 f = m.lotsRemaining > remain ? remain : m.lotsRemaining;

            uint256 price = _tetcPerLotFromTick(t);
            uint256 pay = uint256(f) * price;

            // Taker pays maker in TETC
            require(TETC.transferFrom(msg.sender, m.owner, pay), "TETC pay failed");

            // Contract releases escrowed STRN10K to taker
            require(STRN10K.transfer(msg.sender, uint256(f)), "STRN10K deliver failed");

            m.lotsRemaining -= f;
            lvl.totalLots -= f;
            remain -= f;

            lastFilled = t;
            filled = true;

            if (m.lotsRemaining == 0) {
                _removeHead(false, t);
                delete orders[oid];
            }

            if (lvl.head == 0) {
                int32 nxt = lvl.next;
                _removeTick(false, t);
                if (nxt == NONE) break;
                t = nxt;
            }
        }

        require(remain == 0, "unfilled");
        if (filled) {
            lastTradeTick = lastFilled;
            lastTradeBlock = block.number;
        }
    }

    /// @notice Sell `lots` lots, receiving TETC, crossing the buy book down to `limitTick`.
    /// @dev Transfers are done during the loop (trusted tokens assumption).
    function takeSellFOK(int32 limitTick, uint32 lots) external nonReentrant {
        require(hasBestBuy, "no buys");
        require(lots > 0, "zero lots");

        uint32 remain = lots;
        int32 t = bestBuyTick;
        int32 lastFilled;
        bool filled;

        while (remain > 0) {
            require(t >= limitTick, "FOK");

            TickLevel storage lvl = buyLevels[t];
            uint256 oid = lvl.head;
            require(oid != 0, "empty level");

            Order storage m = orders[oid];
            uint32 f = m.lotsRemaining > remain ? remain : m.lotsRemaining;

            uint256 price = _tetcPerLotFromTick(t);
            uint256 pay = uint256(f) * price;

            // Taker delivers STRN10K to maker (buyer)
            require(STRN10K.transferFrom(msg.sender, m.owner, uint256(f)), "STRN10K pay failed");

            // Contract releases escrowed TETC to taker
            require(TETC.transfer(msg.sender, pay), "TETC deliver failed");

            m.lotsRemaining -= f;
            lvl.totalLots -= f;
            remain -= f;

            lastFilled = t;
            filled = true;

            if (m.lotsRemaining == 0) {
                _removeHead(true, t);
                delete orders[oid];
            }

            if (lvl.head == 0) {
                int32 nxt = lvl.next;
                _removeTick(true, t);
                if (nxt == NONE) break;
                t = nxt;
            }
        }

        require(remain == 0, "unfilled");
        if (filled) {
            lastTradeTick = lastFilled;
            lastTradeBlock = block.number;
        }
    }

    /* ---------- Full Book + Depth Views (single-pass, bounded) ---------- */

    function getFullBuyBook(uint256 maxOrders)
        external
        view
        returns (BookOrder[] memory out, uint256 n)
    {
        return _getFullBookSinglePass(true, maxOrders);
    }

    function getFullSellBook(uint256 maxOrders)
        external
        view
        returns (BookOrder[] memory out, uint256 n)
    {
        return _getFullBookSinglePass(false, maxOrders);
    }

    function _getFullBookSinglePass(bool isBuy, uint256 maxOrders)
        internal
        view
        returns (BookOrder[] memory out, uint256 n)
    {
        if (maxOrders == 0) return (new BookOrder[](0), 0);

        if (isBuy) {
            if (!hasBestBuy) return (new BookOrder[](0), 0);
        } else {
            if (!hasBestSell) return (new BookOrder[](0), 0);
        }

        out = new BookOrder[](maxOrders);
        n = 0;

        if (isBuy) {
            int32 t = bestBuyTick;
            while (t != NONE && n < maxOrders) {
                TickLevel storage lvl = buyLevels[t];
                uint256 oid = lvl.head;
                while (oid != 0 && n < maxOrders) {
                    Order storage o = orders[oid];
                    out[n++] = BookOrder(oid, o.owner, o.tick, o.lotsRemaining);
                    oid = o.next;
                }
                t = lvl.next;
            }
        } else {
            int32 t = bestSellTick;
            while (t != NONE && n < maxOrders) {
                TickLevel storage lvl = sellLevels[t];
                uint256 oid = lvl.head;
                while (oid != 0 && n < maxOrders) {
                    Order storage o = orders[oid];
                    out[n++] = BookOrder(oid, o.owner, o.tick, o.lotsRemaining);
                    oid = o.next;
                }
                t = lvl.next;
            }
        }
    }

    function getBuyBookDepth(uint256 maxLevels)
        external
        view
        returns (BookLevel[] memory out, uint256 n)
    {
        return _getDepthSinglePass(true, maxLevels);
    }

    function getSellBookDepth(uint256 maxLevels)
        external
        view
        returns (BookLevel[] memory out, uint256 n)
    {
        return _getDepthSinglePass(false, maxLevels);
    }

    function _getDepthSinglePass(bool isBuy, uint256 maxLevels)
        internal
        view
        returns (BookLevel[] memory out, uint256 n)
    {
        if (maxLevels == 0) return (new BookLevel[](0), 0);

        if (isBuy) {
            if (!hasBestBuy) return (new BookLevel[](0), 0);
        } else {
            if (!hasBestSell) return (new BookLevel[](0), 0);
        }

        out = new BookLevel[](maxLevels);
        n = 0;

        if (isBuy) {
            int32 t = bestBuyTick;
            while (t != NONE && n < maxLevels) {
                TickLevel storage lvl = buyLevels[t];
                if (lvl.totalLots > 0) out[n++] = BookLevel(t, lvl.totalLots, lvl.orderCount);
                t = lvl.next;
            }
        } else {
            int32 t = bestSellTick;
            while (t != NONE && n < maxLevels) {
                TickLevel storage lvl = sellLevels[t];
                if (lvl.totalLots > 0) out[n++] = BookLevel(t, lvl.totalLots, lvl.orderCount);
                t = lvl.next;
            }
        }
    }

    function getTopOfBook() external view returns (
        bool hasBuy, int32 buyTick, uint32 buyLots, uint32 buyOrders,
        bool hasSell, int32 sellTick, uint32 sellLots, uint32 sellOrders
    ) {
        hasBuy = hasBestBuy;
        buyTick = bestBuyTick;
        if (hasBuy) {
            TickLevel storage b = buyLevels[buyTick];
            buyLots = b.totalLots;
            buyOrders = b.orderCount;
        }

        hasSell = hasBestSell;
        sellTick = bestSellTick;
        if (hasSell) {
            TickLevel storage s = sellLevels[sellTick];
            sellLots = s.totalLots;
            sellOrders = s.orderCount;
        }
    }

    /* ---------- Internals: Orders / Levels ---------- */

    function _newOrder(bool isBuy, int32 tick, uint32 lots) internal returns (uint256 id) {
        id = nextOrderId++;
        orders[id] = Order(msg.sender, tick, lots, isBuy, 0, 0, true);
    }

    function _enqueue(bool isBuy, int32 tick, uint256 id) internal {
        TickLevel storage lvl = isBuy ? buyLevels[tick] : sellLevels[tick];

        if (!lvl.exists) {
            _insertTick(isBuy, tick);
            lvl = isBuy ? buyLevels[tick] : sellLevels[tick];
        }

        if (lvl.tail == 0) {
            lvl.head = id;
            lvl.tail = id;
        } else {
            orders[lvl.tail].next = id;
            orders[id].prev = lvl.tail;
            lvl.tail = id;
        }

        lvl.orderCount++;
        lvl.totalLots += orders[id].lotsRemaining;
    }

    function _insertTick(bool isBuy, int32 tick) internal {
        TickLevel storage lvl = isBuy ? buyLevels[tick] : sellLevels[tick];
        lvl.exists = true;
        lvl.prev = NONE;
        lvl.next = NONE;

        if (isBuy) {
            if (!hasBestBuy) {
                hasBestBuy = true;
                bestBuyTick = tick;
                return;
            }
            int32 cur = bestBuyTick;
            if (tick > cur) {
                lvl.next = cur;
                buyLevels[cur].prev = tick;
                bestBuyTick = tick;
                return;
            }
            while (true) {
                int32 nxt = buyLevels[cur].next;
                if (nxt == NONE || tick > nxt) {
                    lvl.prev = cur;
                    lvl.next = nxt;
                    buyLevels[cur].next = tick;
                    if (nxt != NONE) buyLevels[nxt].prev = tick;
                    return;
                }
                cur = nxt;
            }
        } else {
            if (!hasBestSell) {
                hasBestSell = true;
                bestSellTick = tick;
                return;
            }
            int32 cur = bestSellTick;
            if (tick < cur) {
                lvl.next = cur;
                sellLevels[cur].prev = tick;
                bestSellTick = tick;
                return;
            }
            while (true) {
                int32 nxt = sellLevels[cur].next;
                if (nxt == NONE || tick < nxt) {
                    lvl.prev = cur;
                    lvl.next = nxt;
                    sellLevels[cur].next = tick;
                    if (nxt != NONE) sellLevels[nxt].prev = tick;
                    return;
                }
                cur = nxt;
            }
        }
    }

    function _removeHead(bool isBuy, int32 tick) internal {
        TickLevel storage lvl = isBuy ? buyLevels[tick] : sellLevels[tick];
        uint256 id = lvl.head;
        uint256 n = orders[id].next;
        lvl.head = n;
        if (n == 0) lvl.tail = 0;
        else orders[n].prev = 0;
        lvl.orderCount--;
    }

    function _unlinkOrder(bool isBuy, int32 tick, uint256 id) internal {
        TickLevel storage lvl = isBuy ? buyLevels[tick] : sellLevels[tick];
        Order storage o = orders[id];

        if (o.prev == 0) lvl.head = o.next;
        else orders[o.prev].next = o.next;

        if (o.next == 0) lvl.tail = o.prev;
        else orders[o.next].prev = o.prev;

        lvl.orderCount--;
        if (lvl.head == 0) _removeTick(isBuy, tick);
    }

    function _removeTick(bool isBuy, int32 tick) internal {
        TickLevel storage lvl = isBuy ? buyLevels[tick] : sellLevels[tick];
        int32 p = lvl.prev;
        int32 n = lvl.next;

        if (isBuy) {
            if (p == NONE) bestBuyTick = n;
            else buyLevels[p].next = n;
            if (n != NONE) buyLevels[n].prev = p;
            if (bestBuyTick == NONE) hasBestBuy = false;
            delete buyLevels[tick];
        } else {
            if (p == NONE) bestSellTick = n;
            else sellLevels[p].next = n;
            if (n != NONE) sellLevels[n].prev = p;
            if (bestSellTick == NONE) hasBestSell = false;
            delete sellLevels[tick];
        }
    }

    /* ---------- Price ---------- */

    /// @notice TETC base units per 1 lot at `tick` using 462-ticks/decade mantissa grid.
    /// @dev tick 0 => 1e18. tick range bounded to [-1848, +1848] (decade in [-4, +4]).
    function _tetcPerLotFromTick(int32 tick) internal view returns (uint256 p) {
        require(tick >= MIN_TICK && tick <= MAX_TICK, "tick range");

        int32 decade = tick / 462;
        int32 r = tick % 462;
        if (r < 0) { r += 462; decade -= 1; } // normalize remainder to [0..461]

        uint256 m = mantissa(uint32(uint256(int256(r)))); // 1000..9950
        p = m * 1e15;

        if (decade > 0) {
            p *= POW10[uint32(uint256(int256(decade)))];
        } else if (decade < 0) {
            p /= POW10[uint32(uint256(int256(-decade)))];
        }
    }

    function tetcPerLotForTick(int32 tick) external view returns (uint256) {
        return _tetcPerLotFromTick(tick);
    }

    function getBestTicks() external view returns (bool, int32, bool, int32) {
        return (hasBestBuy, bestBuyTick, hasBestSell, bestSellTick);
    }

    function getLevel(bool isBuy, int32 tick) external view returns (
        bool exists,
        int32 prev,
        int32 next,
        uint256 head,
        uint256 tail,
        uint32 orderCount,
        uint32 totalLots
    ) {
        TickLevel storage l = isBuy ? buyLevels[tick] : sellLevels[tick];
        return (l.exists, l.prev, l.next, l.head, l.tail, l.orderCount, l.totalLots);
    }
}
